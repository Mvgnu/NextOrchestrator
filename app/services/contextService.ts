import { v4 as uuidv4 } from 'uuid';
import supabase from '@/lib/supabase'; // Ensure Supabase client is imported
import type { Database } from '@/types/supabase'; // Import DB types

// Type aliases for context table - Export Row type
export type ContextRow = Database['public']['Tables']['contexts']['Row'];
type ContextInsert = Database['public']['Tables']['contexts']['Insert'];
type ContextUpdate = Database['public']['Tables']['contexts']['Update'];

export interface ContextFile {
  id: string;
  fileName: string;
  fileType: string; 
  content: string;
  size: number;
  createdAt: Date;
  projectId: string;
  userId: string;
}

export interface ContextDigest {
  id: string;
  summary: string;
  keyPoints: string[];
  entities: string[];
  markdown: string;
  sourceFileIds: string[];
  createdAt: Date;
  projectId: string;
}

export interface DigestOptions {
  maxLength?: number;
  focusAreas?: string[];
  includeEntities?: boolean;
  formatType?: 'markdown' | 'json' | 'html';
}

// Mock API for context file upload
export async function uploadContextFile(
  file: File, 
  projectId: string,
  userId: string
): Promise<ContextFile> {
  // In production, this would upload to storage and process the file
  // For now, we'll simulate parsing
  
  // Read the file content
  const content = await readFileAsText(file);
  
  const contextFile: ContextFile = {
    id: uuidv4(),
    fileName: file.name,
    fileType: file.type,
    content: content,
    size: file.size,
    createdAt: new Date(),
    projectId,
    userId
  };
  
  // In production, would save to database here
  
  return contextFile;
}

// Mock API for context digestion
export async function digestContext(
  contextFiles: ContextFile[],
  options: DigestOptions = {}
): Promise<ContextDigest> {
  // In production, this would use an AI model to digest the content
  // For now, we'll simulate this process
  
  // Simulate API processing time
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  // Extract file content for processing
  const combinedContent = contextFiles.map(file => file.content).join('\n\n');
  
  // Very basic simulated digest
  const summaryLines = combinedContent.split('\n').filter(line => line.trim() !== '').slice(0, 5);
  const summary = summaryLines.join('\n');
  
  // Simple key points extraction (just first sentence of each paragraph)
  const paragraphs = combinedContent.split('\n\n');
  const keyPoints = paragraphs
    .slice(0, Math.min(5, paragraphs.length))
    .map(para => para.split('.')[0] + '.')
    .filter(point => point.length > 10);
  
  // Create a simple markdown representation
  const markdown = `# Context Digest

## Summary
${summary}

## Key Points
${keyPoints.map(point => `- ${point}`).join('\n')}

## Content Overview
${contextFiles.map(file => `### ${file.fileName}\n\n${file.content.substring(0, 200)}...\n`).join('\n')}
`;

  return {
    id: uuidv4(),
    summary,
    keyPoints,
    entities: ['simulated', 'entities', 'extracted'],
    markdown,
    sourceFileIds: contextFiles.map(file => file.id),
    createdAt: new Date(),
    projectId: contextFiles[0]?.projectId || ''
  };
}

// In a real production app, this would be a proper AI-powered digest
export async function digestWithAgent(
  contextFiles: ContextFile[],
  options: DigestOptions = {}
): Promise<ContextDigest> {
  // In production, this would call your LLM API with a prompt like:
  // "Please analyze the following content and create a concise digest..."
  
  // Simulate AI processing time
  await new Promise(resolve => setTimeout(resolve, 3000));
  
  // Build a more elaborate simulated response
  const digest: ContextDigest = {
    id: uuidv4(),
    summary: "This is a simulated AI-generated summary of the provided context files. In a real implementation, this would be an intelligent distillation of the key information from all the uploaded files, focusing on the most important aspects while maintaining context integrity.",
    keyPoints: [
      "Document contains important information about project requirements",
      "Several technical specifications are outlined in section 3",
      "Timeline considerations are mentioned in multiple places",
      "Budget constraints are highlighted as a critical factor",
      "Previous work is referenced as a foundation for current efforts"
    ],
    entities: [
      "Project X", "Client Y", "Technology Z", "Framework A", "API B"
    ],
    markdown: `# AI-Generated Context Digest

## Executive Summary
This is a comprehensive analysis of the provided documents that would be generated by a real AI model. The content would be organized into a clear structure with headings, bullet points, and other formatting to make it easily digestible.

## Key Findings
- Finding 1 with detailed explanation and references to source
- Finding 2 with implications for project development
- Finding 3 with connections to other related concepts
- Finding 4 highlighting priority areas

## Critical Factors
1. Factor A - Impact on timeline
2. Factor B - Technical considerations
3. Factor C - Resource requirements

## Recommendations
Based on the analyzed content, the following actions are recommended:
- Recommendation 1
- Recommendation 2
- Recommendation 3

## Source Analysis
The information has been synthesized from multiple sources with appropriate weighting based on relevance and reliability.
`,
    sourceFileIds: contextFiles.map(file => file.id),
    createdAt: new Date(),
    projectId: contextFiles[0]?.projectId || ''
  };
  
  return digest;
}

// Utility function to read file as text
async function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsText(file);
  });
}

// --- NEW CRUD Functions --- 

/**
 * Creates a new context record in the database.
 * Assumes user_id and project_id are provided correctly.
 * 
 * @param contextData - Data for the new context.
 * @returns The newly created context row.
 * @throws Error if creation fails.
 */
async function createContext(contextData: ContextInsert): Promise<ContextRow> {
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    const { data, error } = await supabase
        .from('contexts')
        .insert(contextData)
        .select()
        .single();
    
    if (error) {
        console.error("Error creating context:", error);
        throw new Error(`Failed to create context: ${error.message}`);
    }
    if (!data) {
        throw new Error('Context creation returned no data.');
    }
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    return data;
}

/**
 * Retrieves all contexts for a specific project belonging to the user.
 * 
 * @param projectId - The ID of the project.
 * @param userId - The ID of the authenticated user.
 * @returns An array of context rows.
 * @throws Error if fetching fails.
 */
async function getProjectContexts(projectId: string, userId: string): Promise<ContextRow[]> {
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    const { data, error } = await supabase
        .from('contexts')
        .select('*') // Select all columns, or specify needed ones (id, name, summary?)
        .eq('project_id', projectId)
        .eq('user_id', userId)
        .order('created_at', { ascending: false });

    if (error) {
        console.error("Error fetching project contexts:", error);
        throw new Error(`Failed to fetch contexts for project ${projectId}: ${error.message}`);
    }
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    return data || [];
}

/**
 * Retrieves a single context document by its ID, ensuring user access.
 *
 * @param contextId - The ID of the context to retrieve.
 * @param userId - The ID of the authenticated user.
 * @returns The context row or null if not found/accessible.
 * @throws Error if fetching fails.
 */
async function getContext(contextId: string, userId: string): Promise<ContextRow | null> {
     // @ts-ignore - Supabase types might need regeneration for 'contexts'
    const { data, error } = await supabase
        .from('contexts')
        .select('*')
        .eq('id', contextId)
        .eq('user_id', userId)
        .maybeSingle(); // Use maybeSingle to return null if not found

    if (error) {
        console.error(`Error fetching context ${contextId}:`, error);
        throw new Error(`Failed to fetch context: ${error.message}`);
    }
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    return data;
}

/**
 * Retrieves multiple context documents by their IDs, ensuring user access.
 * 
 * @param contextIds - An array of context IDs to retrieve.
 * @param userId - The ID of the authenticated user.
 * @returns An array of context rows found and accessible by the user.
 * @throws Error if fetching fails.
 */
async function getContextsByIds(contextIds: string[], userId: string): Promise<ContextRow[]> {
    if (!contextIds || contextIds.length === 0) {
        return [];
    }
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    const { data, error } = await supabase
        .from('contexts')
        .select('*')
        .eq('user_id', userId) // Ensure user owns the contexts
        .in('id', contextIds); // Filter by the provided IDs
    
    if (error) {
        console.error("Error fetching contexts by IDs:", error);
        throw new Error(`Failed to fetch contexts by IDs: ${error.message}`);
    }
    // @ts-ignore - Supabase types might need regeneration for 'contexts'
    return data || [];
}

/**
 * Updates an existing context document.
 *
 * @param contextId - The ID of the context to update.
 * @param userId - The ID of the authenticated user (for authorization).
 * @param updates - An object containing the fields to update.
 * @returns The updated context row.
 * @throws Error if update fails or context not found/accessible.
 */
async function updateContext(contextId: string, userId: string, updates: ContextUpdate): Promise<ContextRow> {
     // @ts-ignore - Supabase types might need regeneration for 'contexts'
    const { data, error } = await supabase
        .from('contexts')
        .update(updates)
        .eq('id', contextId)
        .eq('user_id', userId) // Ensure user owns the context
        .select()
        .single();
    
    if (error) {
        console.error(`Error updating context ${contextId}:`, error);
        // Differentiate between not found and other errors if needed
        if (error.code === 'PGRST116') { // Example code for no rows found
             throw new Error('Context not found or access denied.');
        }
        throw new Error(`Failed to update context: ${error.message}`);
    }
     if (!data) {
        throw new Error('Context not found or access denied after update.');
    }
     // @ts-ignore - Supabase types might need regeneration for 'contexts'
    return data;
}

/**
 * Deletes a context document.
 *
 * @param contextId - The ID of the context to delete.
 * @param userId - The ID of the authenticated user (for authorization).
 * @throws Error if deletion fails or context not found/accessible.
 */
async function deleteContext(contextId: string, userId: string): Promise<void> {
     // @ts-ignore - Supabase types might need regeneration for 'contexts'
    const { error } = await supabase
        .from('contexts')
        .delete()
        .eq('id', contextId)
        .eq('user_id', userId);
        
    if (error) {
        console.error(`Error deleting context ${contextId}:`, error);
         if (error.code === 'PGRST116') { // Not found might return error or just 0 count
             throw new Error('Context not found or access denied.');
        }
        throw new Error(`Failed to delete context: ${error.message}`);
    }
    // We might want to check the count returned if the API supports it
}

// Export the service object with all functions
export const ContextService = {
  // CRUD
  createContext,
  getContext,
  getProjectContexts,
  updateContext,
  deleteContext,
  // Existing mocks
  uploadContextFile, 
  digestContext,
  digestWithAgent,
  getContextsByIds
};

// Maintain default export if used elsewhere
export default ContextService; 